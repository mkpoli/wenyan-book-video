import {
  copyFileSync,
  existsSync,
  mkdirSync,
  readdirSync,
  readFileSync,
  writeFileSync,
} from "fs";
import { parseFile } from "music-metadata";
import path, { join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT =
  process.env.PROJECT_ROOT ?? join(__dirname, "..", "..");
const RENDERER_DIR =
  process.env.RENDERER_DIR ?? join(__dirname, "..");
const SEGMENTS_DIR = join(PROJECT_ROOT, "segments");
const AUDIOS_DIR = join(PROJECT_ROOT, "audios");
const GENERATED_DIR = join(RENDERER_DIR, "src", "generated");
const GENERATED_SEGMENTS_FILE = join(GENERATED_DIR, "segments.ts");
const PUBLIC_AUDIO_DIR = join(RENDERER_DIR, "public", "audios");
const FPS = 30;
const AUDIO_TAIL_FRAMES = 12;
const DEFAULT_AUDIO_DURATION_SECONDS = 3;

const isDebug = process.env.DEBUG_SEGMENTS === "1";
const debugLog = (...args: unknown[]) => {
  if (isDebug) {
    // eslint-disable-next-line no-console
    console.log("[segments]", ...args);
  }
};

const getAudioDurationInSeconds = async (audioPath: string) => {
  try {
    const metadata = await parseFile(audioPath);
    if (metadata.format.duration) {
      return metadata.format.duration;
    }
  } catch (error) {
    const message =
      error instanceof Error ? error.message : JSON.stringify(error);
    console.warn(
      `[segments] Failed to parse duration for ${audioPath}: ${message}`,
    );
  }

  console.warn(
    `[segments] Falling back to default duration (${DEFAULT_AUDIO_DURATION_SECONDS}s) for ${audioPath}`,
  );
  return DEFAULT_AUDIO_DURATION_SECONDS;
};

const generateSegments = async () => {
  let entries: Array<{
    id: string;
    text: string;
    audioPath: string;
    durationInFrames: number;
  }> = [];

  try {
    const files = readdirSync(SEGMENTS_DIR).filter((file) =>
      file.endsWith(".txt"),
    );

    entries = (
      await Promise.all(
        files.map(async (file) => {
          const id = file.replace(".txt", "");
          const audioFile = `audio-${id}.mp3`;
          const femaleAudioFile = `audio-${id}-f.mp3`;
          const maleAudioPath = join(AUDIOS_DIR, audioFile);
          const femaleAudioPath = join(AUDIOS_DIR, "female", femaleAudioFile);
          const hasFemaleAudio = existsSync(femaleAudioPath);
          const sourceAudioPath = hasFemaleAudio ? femaleAudioPath : maleAudioPath;
          const publicAudioFile = hasFemaleAudio ? femaleAudioFile : audioFile;

          if (!existsSync(sourceAudioPath)) {
            debugLog(`Skipping ${file} (no matching audio).`);
            return null;
          }

          const segmentPath = join(SEGMENTS_DIR, file);
          const text = readFileSync(segmentPath, "utf-8").trim();

          mkdirSync(PUBLIC_AUDIO_DIR, { recursive: true });
          copyFileSync(
            sourceAudioPath,
            join(PUBLIC_AUDIO_DIR, publicAudioFile),
          );

          if (hasFemaleAudio) {
            debugLog(`Using female voice for segment ${id}.`);
          }

          const durationInSeconds = await getAudioDurationInSeconds(
            sourceAudioPath,
          );
          const durationInFrames =
            Math.ceil(durationInSeconds * FPS) + AUDIO_TAIL_FRAMES;

          return {
            id,
            text,
            audioPath: `audios/${publicAudioFile}`,
            durationInFrames,
          };
        }),
      )
    )
      .filter((entry): entry is NonNullable<typeof entry> => entry !== null)
      .sort((a, b) => {
        const [aChapter, aSegment] = a.id.split("-").map(Number);
        const [bChapter, bSegment] = b.id.split("-").map(Number);

        if (aChapter !== bChapter) {
          return aChapter - bChapter;
        }

        return aSegment - bSegment;
      });
  } catch (error) {
    console.error("[segments] Failed to read segments:", error);
    entries = [];
  }

  mkdirSync(GENERATED_DIR, { recursive: true });

  const fileContents =
    `// Auto-generated by renderer/scripts/generate-segments.ts. Do not edit manually.\n` +
    `// Generated at ${new Date().toISOString()}\n\n` +
    `export const segments = ${JSON.stringify(entries, null, 2)} as const;\n` +
    `export type Segment = typeof segments[number];\n`;

  writeFileSync(GENERATED_SEGMENTS_FILE, fileContents);
};

generateSegments()
  .then(() => {
    debugLog("Segment metadata generation complete.");
  })
  .catch((error) => {
    console.error("[segments] Segment metadata generation failed:", error);
    process.exitCode = 1;
  });

